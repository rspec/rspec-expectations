module RSpec
  module Matchers
    @@repository = Hash.new

    def self.matcher(name)
      @@repository[name]
    end

    def self.factory(name, &declarations)
      klass = Class.new(Matcher)
      klass.set_defaults!(name)
      klass.class_eval(&declarations)
      @@repository[name] = klass
    end

    # Provides the context in which the block passed to RSpec::Matchers.define
    # will be evaluated.
    class Matcher
      include RSpec::Matchers::Pretty
      include RSpec::Matchers

      attr_reader :name, :expected, :actual, :rescued_exception

      class << self
        # Set default instance variables for this class.
        #
        # @api private
        def set_defaults!(name)
          @diffable = false
          @matcher_name = name
          @expected_exception = nil
        end

        attr_reader :matcher_name, :expected_exception

        # Tells the matcher to diff the actual and expected values in the failure
        # message.
        def diffable
          @diffable = true
        end

        # @api private
        # Used internally by objects returns by +should+ and +should_not+.
        def diffable?
          @diffable
        end

        # Stores the block that is used to determine whether this matcher passes
        # or fails. The block should return a boolean value. When the matcher is
        # passed to `should` and the block returns `true`, then the expectation
        # passes. Similarly, when the matcher is passed to `should_not` and the
        # block returns `false`, then the expectation passes.
        #
        # Use `match_for_should` when used in conjuntion with
        # `match_for_should_not`.
        #
        # @example
        #
        #     RSpec::Matchers.define :be_even do
        #       match do |actual|
        #         actual.even?
        #       end
        #     end
        #
        #     4.should be_even     # passes
        #     3.should_not be_even # passes
        #     3.should be_even     # fails
        #     4.should_not be_even # fails
        #
        # @yield [Object] actual the actual value (or receiver of should)
        def match(&block)
          define_method(:match, &block)
        end
        alias_method :match_for_should, :match

        # Use this to define the block for a negative expectation (`should_not`)
        # when the positive and negative forms require different handling. This
        # is rarely necessary, but can be helpful, for example, when specifying
        # asynchronous processes that require different timeouts.
        #
        # @yield [Object] actual the actual value (or receiver of should)
        def match_for_should_not(&block)
          define_method(:match_for_should_not, &block)
        end

        # Use this instead of `match` when the block will raise an exception
        # rather than returning false to indicate a failure.
        #
        # @example
        #
        #     RSpec::Matchers.define :accept_as_valid do |candidate_address|
        #       match_unless_raises ValidationException do |validator|
        #         validator.validate(candidate_address)
        #       end
        #     end
        #
        #     email_validator.should accept_as_valid("person@company.com")
        def match_unless_raises(exception=Exception, &block)
          @expected_exception = exception
          match(&block)
        end

        # Customize the description to use for one-liners.  Only use this when
        # the description generated by default doesn't suit your needs.
        #
        # @example
        #
        #     RSpec::Matchers.define :qualify_for do |expected|
        #       match { ... }
        #
        #       description do
        #         "qualify for #{expected}"
        #       end
        #     end
        def description(&block)
          define_method(:description, &block)
        end

        # Customize the failure messsage to use when this matcher is invoked with
        # `should`. Only use this when the message generated by default doesn't
        # suit your needs.
        #
        # @example
        #
        #     RSpec::Matchers.define :have_strength do |expected|
        #       match { ... }
        #
        #       failure_message_for_should do |actual|
        #         "Expected strength of #{expected}, but had #{actual.strength}"
        #       end
        #     end
        #
        # @yield [Object] actual the actual object
        def failure_message_for_should(&block)
          define_method(:failure_message_for_should, &block)
        end

        # Customize the failure messsage to use when this matcher is invoked with
        # `should_not`. Only use this when the message generated by default
        # doesn't suit your needs.
        #
        # @example
        #
        #     RSpec::Matchers.define :have_strength do |expected|
        #       match { ... }
        #
        #       failure_message_for_should_not do |actual|
        #         "Expected not to have strength of #{expected}, but did"
        #       end
        #     end
        #
        # @yield [Object] actual the actual object
        # @yield [Object] actual the actual object
        def failure_message_for_should_not(&block)
          define_method(:failure_message_for_should_not, &block)
        end

        # Convenience for defining methods on this matcher to create a fluent
        # interface. The trick about fluent interfaces is that each method must
        # return self in order to chain methods together. `chain` handles that
        # for you.
        #
        # @example
        #
        #     RSpec::Matchers.define :have_errors_on do |key|
        #       chain :with do |message|
        #         @message = message
        #       end
        #
        #       match do |actual|
        #         actual.errors[key] == @message
        #       end
        #     end
        #
        #     minor.should have_errors_on(:age).with("Not old enough to participate")
        def chain(method, &block)
          define_method method do |*args|
            block.call(*args)
            self
          end
        end
      end

      # @api private
      def initialize(context, *expected)
        @name     = self.class.matcher_name
        @actual   = nil
        @expected = expected.first # TODO: Backwards incompatible
        @context  = context
        @rescued_exception = nil
      end

      # @api private
      # Used internally by +should+ and +should_not+.
      def matches?(actual)
        @actual = actual

        if self.class.expected_exception
          begin
            match(actual)
            true
          rescue self.class.expected_exception => @rescued_exception
            false
          end
        else
          begin
            match(actual)
            true
          rescue RSpec::Expectations::ExpectationNotMetError
            false
          end
        end
      end

      # Default message for should, may be overriden in the DSL.
      def failure_message_for_should
        "expected #{actual.inspect} to #{name_to_sentence}#{expected_to_sentence}"
      end

      # Default message for should not, may be overriden in the DSL.
      def failure_message_for_should_not
        "expected #{actual.inspect} not to #{name_to_sentence}#{expected_to_sentence}"
      end

      # Default description, may be overriden in the DSL.
      def description
        "#{name_to_sentence}#{expected_to_sentence}"
      end

      # @api private
      # Used internally by +should_not+
      def does_not_match?(actual)
        @actual = actual
        respond_to?(:match_for_should_not) ?
          match_for_should_not(actual) :
          !matches?(actual)
      end

      def respond_to?(method, include_private=false)
        @context.respond_to?(method, include_private) || super
      end

    private

      def method_missing(method, *args, &block)
        if @context.respond_to?(method)
          @context.send method, *args, &block
        else
          super(method, *args, &block)
        end
      end
    end
  end
end
